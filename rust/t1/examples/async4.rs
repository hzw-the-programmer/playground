use futures::executor::block_on;
use futures::future::Future;

/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // let n: i32 = my_string;
        // ...
        println!("future_one: {my_string}");
    };

    let future_two = async {
        // let n: i32 = my_string;
        // ...
        println!("future_two: {my_string}");
    };

    // Run both futures to completion, printing "foo" twice:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async move` block can access the same captured variable, since
/// captures are moved into the `Future` generated by the `async move` block.
/// However, this allows the `Future` to outlive the original scope of the
/// variable:
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // let n: i32 = my_string;
        // ...
        println!("{my_string}");
    }
}

async fn async_main() {
    blocks().await;
    move_block().await;
}

fn main() {
    block_on(async_main());
}
