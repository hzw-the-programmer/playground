MTK地址没4字节对齐，取整数错误。

## 代码
```
void test() {
    uint8 *buf = malloc(16);
    int32 i = 0;
    uint32 num = 0;

    // 初始化为：000102030405060708090a0b0c0d0e0f
    for (i = 0; i < 16; i++) {
        buf[i] = i;
    }

    // 连续4字节整形输出
    for (i = 0; i < 13; i++) {
        num = *(uint32*)(buf + i);
        printf("test 0x%08x=0x%08x", buf + i, num);
    }
}
```

## 输出
```
test 0xf02c169c=0x03020100
test 0xf02c169d=0x00030201
test 0xf02c169e=0x01000302
test 0xf02c169f=0x02010003
test 0xf02c16a0=0x07060504
test 0xf02c16a1=0x04070605
test 0xf02c16a2=0x05040706
test 0xf02c16a3=0x06050407
test 0xf02c16a4=0x0b0a0908
test 0xf02c16a5=0x080b0a09
test 0xf02c16a6=0x09080b0a
test 0xf02c16a7=0x0a09080b
test 0xf02c16a8=0x0f0e0d0c
```

## 分析
内存内容如下：000102030405060708090a0b0c0d0e0f

输出1：
地址0xf02c169c，4字节对齐（地址除4无余数），输出0x03020100，小端，正确。

输出2：
地址0xf02c169d，未4字节对齐（地址除4有余数），输出0x00030201，期望输出0x04030201

输出3：
地址0xf02c169e，未4字节对齐（地址除4有余数），输出0x01000302，期望输出0x05040302

输出4：
地址0xf02c169f，未4字节对齐（地址除4有余数），输出0x02010003，期望输出0x06050403

输出5：
地址0xf02c16a0，4字节对齐（地址除4无余数），输出0x07060504，小端，正确。

输出6：
地址0xf02c16a1，未4字节对齐（地址除4有余数），输出0x04070605，期望输出0x08070605

...

## 结论
int i = *(int*)ptr;
该代码只有在ptr存储的地址为4字节对齐时，取得整数才正确。

### 解决办法1，依赖平台大小端
```
int i = 0;
memcpy(&i, ptr, 4);
```

### 解决办法2，推荐，不依赖平台大小端
```
int i = 0;
i = ptr[0] || (ptr[1] << 8) || (ptr[2] << 16) || (ptr[3] << 24);
```
